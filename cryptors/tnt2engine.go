// Package cryptors - define tnt2Engine type and it's methods
package cryptors

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"math/big"
	"math/bits"
	"os"

	"github.com/bgallie/utilities"
)

var (
	counter          *cryptors.Counter = new(cryptors.Counter)
	proFormaMachine  []cryptors.Crypter
	tntMachine       []cryptors.Crypter
	rotorSizes       []int
	rotorSizesIndex  int
	cycleSizes       []int
	cycleSizesIndex  int
	cMap             map[string]*big.Int
	cntrFileName     string
	inputFileName    string
	outputFileName   string
	logFileName      string
	proFormaFileName string
	proFormaFile     os.File
	perm             func(int) []byte
	intn             func(int) int
	inputFile        = os.Stdin
	outputFile       = os.Stdout
	checkFatal       = utilities.CheckFatal
	turnOffLogging   = utilities.TurnOffLogging
	turnOnLogging    = utilities.TurnOnLogging
	setLogFileName   = utilities.SetLogFileName
)

type tnt2Engine struct {
	engineType string // "Encrypt" or "Decrypt"
	engine     []Crypter
	input      *io.PipeReader
	output     *io.PipeWriter
}

func (e *tnt2Engine) Input() *io.PipeReader {
	return e.input
}

func (e *tnt2Engine) Output() *io.PipeWriter {
	return e.output
}

func (e *tnt2Engine) Index() (cntr *big.Int) {
	if len(e.engine) != 0 {
		machine := e.engine[len(e.engine)-1]
		switch machine.(type) {
		default:
			cntr = BigZero
		case *Counter:
			cntr = machine.Index()
		}
	}

	return
}

func (e *tnt2Engine) SetIndex(iCnt *big.Int) {
	for _, machine := range e.engine {
		machine.SetIndex(iCnt)
	}
}

func (e *tnt2Engine) Init(secret []byte, proFormaFile os.File) {

}

/*
	createRandomNumberFunction returns a function [func(max int) int] that will
	return a uniform random value in [0, max) using psudo-random bytes generated
	by the TNT2 encryption algorithm. It panics if max <= 0.

	'left' is the input channel and 'right' is the output channel for the TNT2
	encryption machine.
*/
func createRandomNumberFunction(left chan CypherBlock, right chan CypherBlock) func(int) int {
	/*
		'blk' contains the data that is encrypted and is initializd to data
		generated from the uberJc1 algorithm based on the secret key enterd
		by the user.
	*/
	var blk CypherBlock
	blk.Length = CypherBlockBytes
	blkSlice := blk.CypherBlock[:]
	go copy(blkSlice, key.XORKeyStream(blkSlice))

	return func(max int) int {
		for {
			if max <= 0 {
				panic("argument to intn is <= 0")
			}

			n := max - 1
			// bitLen is the maximum bit length needed to encode a value < max.
			bitLen := bits.Len(uint(n))
			if bitLen == 0 {
				// the only valid result is 0
				return n
			}
			// k is the maximum byte length needed to encode a value < max.
			k := (bitLen + 7) / 8
			// b is the number of bits in the most significant byte of max-1.
			b := uint(bitLen % 8)
			if b == 0 {
				b = 8
			}

			bytes := make([]byte, k)

			for {
				// If there are not enough bytes in 'blk' to get 'k' bytes, get
				// the next 32 psudo-random bytes into 'blk'
				if blk.Length+int8(k) > 31 {
					blk.Length = CypherBlockBytes
					left <- blk
					blk = <-right
					blk.Length = 0
				}
				// Get the next 'k' psudo-random bytes generated by the TNT2
				// encryption machine.
				copy(bytes[0:], blk.CypherBlock[blk.Length:blk.Length+int8(k)])
				blk.Length += int8(k)

				// Clear bits in the first byte to increase the probability
				// that the candidate is < max.
				bytes[0] &= uint8(int(1<<b) - 1)

				// Change the data in the byte slice into an integer ('n')
				n = 0
				for _, val := range bytes {
					n = (n << 8) | int(val)
				}

				if n < max {
					return n
				}
			}
		}
	}
}

/*
	createProFormaMachine initializes the pro-forma machine used to create the
	TNT2 encryption machine.  If the machineFileName is not empty then the
	pro-forma machine is loaded from that file, else the hardcoded rotors and
	permutators are used to initialize the pro-formaa machine.
*/
func createProFormaMachine(machineFileName string) *[]Crypter {
	var newMachine []Crypter
	if len(machineFileName) == 0 {
		log.Println("Using built in proforma rotors and permutators")

		// Create the proforma encryption machine.  The layout of the machine is:
		// 		rotor, rotor, permutator, rotor, rotor, permutator, rotor, rotor
		newMachine = []Crypter{Rotor1, Rotor2, Permutator1,
			Rotor3, Rotor4, Permutator2,
			Rotor5, Rotor6}
	} else {
		log.Printf("Using proforma rotors and permutators from %s\n", machineFileName)
		in, err := os.Open(machineFileName)
		checkFatal(err)
		jDecoder := json.NewDecoder(in)
		// Create the proforma encryption machine from the given proforma machine file.
		// The layout of the machine is:
		// 		rotor, rotor, permutator, rotor, rotor, permutator, rotor, rotor
		var rotor1, rotor2, rotor3, rotor4, rotor5, rotor6 *Rotor
		var permutator1, permutator2 *Permutator
		newMachine = []Crypter{rotor1, rotor2, permutator1, rotor3, rotor4, permutator2, rotor5, rotor6}

		for cnt, machine := range newMachine {
			switch v := machine.(type) {
			default:
				fmt.Fprintf(os.Stderr, "Unknown machine: %v\n", v)
			case *Rotor:
				r := new(Rotor)
				err = jDecoder.Decode(&r)
				checkFatal(err)
				newMachine[cnt] = r
			case *Permutator:
				p := new(Permutator)
				err = jDecoder.Decode(&p)
				checkFatal(err)
				newMachine[cnt] = p
			}
		}
	}

	return &newMachine
}

/*
	updateRotor will update the given (proforma) rotor in place using (psudo-
	random) data generated by the TNT2 encrytption algorithm using the pro-forma
	rotors and permutators.
*/
func updateRotor(r *Rotor, left, right chan CypherBlock) {
	// Get size, start and step of the new rotor
	rotorSize := RotorSizes[rotorSizesIndex]
	rotorSizesIndex = (rotorSizesIndex + 1) % len(RotorSizes)
	start := intn(rotorSize)
	step := intn(rotorSize)

	// blkCnt is the total number of bytes needed to hold rotorSize bits + a slice of 256 bits
	blkCnt := (((rotorSize + CypherBlockSize + 7) / 8) + 31) / 32
	// blkBytes is the number of bytes rotor r needs to increase to hold the new rotor.
	blkBytes := (blkCnt * 32) - len(r.Rotor)
	// Adjust the size of r.Rotor to match the new rotor size.
	adjRotor := make([]byte, blkBytes)
	r.Rotor = append(r.Rotor, adjRotor...)
	var blk CypherBlock
	blk.Length = CypherBlockBytes
	blkSlice := blk.CypherBlock[:]
	// Fill the rotor with random data using TNT2 encryption to generate the
	// random data by encrypting the next 32 bytes of data from the uberJC1
	// algorithm until the next rotor is filled.
	for i := 0; i < blkCnt; i++ {
		copy(blkSlice, key.XORKeyStream(blkSlice))
		left <- blk
		blk = <-right
		copy(r.Rotor[i*CypherBlockBytes:], blk.CypherBlock[:])
	}

	// update the rotor with the new size, start, and step and slice the first
	// 256 bits of the rotor to the end of the rotor.
	r.Update(rotorSize, start, step)
}

/*
	updatePermutator will update the given (proforma) permutator in place using
	(psudo-random) data generated by the TNT2 encrytption algorithm using the
	proforma rotors and permutators.
*/
func updatePermutator(p *Permutator, left, right chan CypherBlock) {
	var randp [CypherBlockSize]byte
	// Create a table of byte values [0...255] in a random order
	for i, val := range perm(CypherBlockSize) {
		randp[i] = val
	}
	// Chose a CycleSizes and randomize order of the values
	length := len(CycleSizes[cycleSizesIndex])
	cycles := make([]int, length, length)
	randi := perm(length)
	for idx, val := range randi {
		cycles[idx] = CycleSizes[cycleSizesIndex][val]
	}
	p.Update(cycles, randp[:])
	cycleSizesIndex = (cycleSizesIndex + 1) % len(CycleSizes)
}
